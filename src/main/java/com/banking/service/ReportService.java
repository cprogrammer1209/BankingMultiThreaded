package com.banking.service;

import com.banking.model.Account;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.StampedLock;

public class ReportService {
    private final AccountService accountService;
    private final ReadWriteLock reportLock;
    private final StampedLock statisticsLock;
    private final ConcurrentHashMap<String, String> reportCache;
    
    // Statistics data protected by StampedLock
    private volatile double totalBalance;
    private volatile long totalTransactions;
    private volatile int activeAccounts;
    
    public ReportService(AccountService accountService) {
        this.accountService = accountService;
        this.reportLock = new ReentrantReadWriteLock();
        this.statisticsLock = new StampedLock();
        this.reportCache = new ConcurrentHashMap<>();
        
        // Initialize statistics
        updateStatistics();
    }
    
    // Uses ReadWriteLock - allows multiple concurrent readers
    public String generateAccountReport(String accountId) {
        reportLock.readLock().lock();
        try {
            System.out.printf("[%s] Generating account report for %s (ReadLock acquired)%n", 
                    Thread.currentThread().getName(), accountId);
            
            // Check cache first
            String cachedReport = reportCache.get(accountId);
            if (cachedReport != null) {
                System.out.printf("[%s] Returning cached report for %s%n", 
                        Thread.currentThread().getName(), accountId);
                return cachedReport;
            }
            
            // Simulate report generation time
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return "Report generation interrupted";
            }
            
            try {
                Account account = accountService.getAccount(accountId);
                String report = String.format(
                        "=== Account Report ===\n" +
                        "Account ID: %s\n" +
                        "Balance: $%.2f\n" +
                        "Transaction Count: %d\n" +
                        "Last Activity: %s\n" +
                        "Report Generated by: %s\n" +
                        "=====================",
                        account.getAccountId(),
                        account.getBalance(),
                        account.getTransactionCount(),
                        account.getLastActivity(),
                        Thread.currentThread().getName()
                );
                
                // Cache the report
                reportCache.put(accountId, report);
                
                System.out.printf("[%s] Generated new report for %s%n", 
                        Thread.currentThread().getName(), accountId);
                
                return report;
                
            } catch (Exception e) {
                return "Error generating report: " + e.getMessage();
            }
            
        } finally {
            reportLock.readLock().unlock();
            System.out.printf("[%s] Released ReadLock for account %s%n", 
                    Thread.currentThread().getName(), accountId);
        }
    }
    
    // Uses ReadWriteLock write lock - exclusive access for cache updates
    public void invalidateReportCache() {
        reportLock.writeLock().lock();
        try {
            System.out.printf("[%s] Invalidating report cache (WriteLock acquired)%n", 
                    Thread.currentThread().getName());
            
            reportCache.clear();
            
            // Simulate cache cleanup time
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.printf("[%s] Report cache invalidated%n", Thread.currentThread().getName());
            
        } finally {
            reportLock.writeLock().unlock();
            System.out.printf("[%s] Released WriteLock%n", Thread.currentThread().getName());
        }
    }
    
    // Uses StampedLock for optimized reading
    public String calculateBankStatistics() {
        long stamp = statisticsLock.tryOptimisticRead();
        
        // Try optimistic read first
        double balance = totalBalance;
        long transactions = totalTransactions;
        int accounts = activeAccounts;
        
        if (!statisticsLock.validate(stamp)) {
            // Optimistic read failed, fall back to read lock
            stamp = statisticsLock.readLock();
            try {
                System.out.printf("[%s] Optimistic read failed, using read lock for statistics%n", 
                        Thread.currentThread().getName());
                
                balance = totalBalance;
                transactions = totalTransactions;
                accounts = activeAccounts;
                
            } finally {
                statisticsLock.unlockRead(stamp);
            }
        } else {
            System.out.printf("[%s] Used optimistic read for statistics%n", 
                    Thread.currentThread().getName());
        }
        
        // Simulate calculation time
        try {
            Thread.sleep(150);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return "Statistics calculation interrupted";
        }
        
        return String.format(
                "=== Bank Statistics ===\n" +
                "Total Balance: $%.2f\n" +
                "Total Transactions: %d\n" +
                "Active Accounts: %d\n" +
                "Average Balance: $%.2f\n" +
                "Calculated by: %s\n" +
                "======================",
                balance,
                transactions,
                accounts,
                accounts > 0 ? balance / accounts : 0.0,
                Thread.currentThread().getName()
        );
    }
    
    // Uses StampedLock write lock for updating statistics
    public void updateStatistics() {
        long stamp = statisticsLock.writeLock();
        try {
            System.out.printf("[%s] Updating bank statistics (StampedLock WriteLock acquired)%n", 
                    Thread.currentThread().getName());
            
            // Simulate statistics calculation
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
            
            // In a real implementation, we would calculate these from the account service
            // For demo purposes, we'll use some sample values
            totalBalance = Math.random() * 100000;
            totalTransactions = (long) (Math.random() * 1000);
            activeAccounts = (int) (Math.random() * 50) + 10;
            
            System.out.printf("[%s] Statistics updated - Balance: %.2f, Transactions: %d, Accounts: %d%n", 
                    Thread.currentThread().getName(), totalBalance, totalTransactions, activeAccounts);
            
        } finally {
            statisticsLock.unlockWrite(stamp);
            System.out.printf("[%s] Released StampedLock WriteLock%n", Thread.currentThread().getName());
        }
    }
    
    public void printLockStatistics() {
        System.out.println("\n=== Lock Statistics ===");
        
        ReadWriteLock rwLock = reportLock;
        if (rwLock instanceof ReentrantReadWriteLock) {
            ReentrantReadWriteLock rrwLock = (ReentrantReadWriteLock) rwLock;
            System.out.printf("ReadWriteLock - Read locks: %d, Write locked: %s, Queue length: %d%n",
                    rrwLock.getReadLockCount(),
                    rrwLock.isWriteLocked(),
                    rrwLock.getQueueLength());
        }
        
        System.out.printf("Report cache size: %d%n", reportCache.size());
        System.out.printf("Current statistics - Balance: %.2f, Transactions: %d, Accounts: %d%n",
                totalBalance, totalTransactions, activeAccounts);
        System.out.println("======================\n");
    }
}